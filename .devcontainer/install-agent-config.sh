#!/bin/bash
set -euo pipefail

# install-agent-config.sh
# Reads config.json and secrets.json, hydrates templates, installs GSD framework,
# restores credentials, and prints a summary.
# Safe to run multiple times (naturally idempotent).

# Constants and paths
WORKSPACE_ROOT="/workspace"
CONFIG_FILE="$WORKSPACE_ROOT/config.json"
SECRETS_FILE="$WORKSPACE_ROOT/secrets.json"
AGENT_CONFIG_DIR="$WORKSPACE_ROOT/agent-config"
CLAUDE_DIR="${CLAUDE_CONFIG_DIR:-/home/node/.claude}"
SETTINGS_TEMPLATE="$AGENT_CONFIG_DIR/settings.json.template"
MCP_TEMPLATES_DIR="$AGENT_CONFIG_DIR/mcp-templates"

# JSON validation helper
validate_json() {
    local file="$1"
    local label="$2"
    if ! jq empty < "$file" &>/dev/null; then
        echo "[install] ERROR: $label is not valid JSON — skipping"
        return 1
    fi
    return 0
}

# Initialize counters for summary
CONFIG_STATUS="defaults — config.json not found"
SECRETS_STATUS="empty placeholders — secrets.json not found"
CREDS_STATUS="missing — manual login required"
CODEX_CREDS_STATUS="missing — manual login required"
GIT_IDENTITY_STATUS="not set"
MCP_COUNT=0
GSD_COMMANDS=0
GSD_AGENTS=0

# Load config.json (or use defaults)
if [ -f "$CONFIG_FILE" ]; then
    if validate_json "$CONFIG_FILE" "config.json"; then
        CONFIG_STATUS="loaded"
        LANGFUSE_HOST=$(jq -r '.langfuse.host // "http://host.docker.internal:3052"' "$CONFIG_FILE")
        EXTRA_DOMAINS=$(jq -r '.firewall.extra_domains // [] | join(" ")' "$CONFIG_FILE")
    else
        LANGFUSE_HOST="http://host.docker.internal:3052"
        EXTRA_DOMAINS=""
    fi
else
    echo "[install] config.json not found — using defaults"
    LANGFUSE_HOST="http://host.docker.internal:3052"
    EXTRA_DOMAINS=""
fi

# Load secrets.json (or use empty placeholders)
if [ -f "$SECRETS_FILE" ]; then
    if validate_json "$SECRETS_FILE" "secrets.json"; then
        SECRETS_STATUS="loaded"
        LANGFUSE_PUBLIC_KEY=$(jq -r '.infra.langfuse_project_public_key // ""' "$SECRETS_FILE")
        LANGFUSE_SECRET_KEY=$(jq -r '.infra.langfuse_project_secret_key // ""' "$SECRETS_FILE")

        # Check for missing individual secrets
        if [ -z "$LANGFUSE_PUBLIC_KEY" ]; then
            echo "[install] secrets.json: infra.langfuse_project_public_key missing — tracing will not work"
        fi
        if [ -z "$LANGFUSE_SECRET_KEY" ]; then
            echo "[install] secrets.json: infra.langfuse_project_secret_key missing — tracing will not work"
        fi
    else
        LANGFUSE_PUBLIC_KEY=""
        LANGFUSE_SECRET_KEY=""
    fi
else
    echo "[install] secrets.json not found — using empty placeholders"
    LANGFUSE_PUBLIC_KEY=""
    LANGFUSE_SECRET_KEY=""
fi

# Get MCP Gateway URL from environment or default
MCP_GATEWAY_URL="${MCP_GATEWAY_URL:-http://host.docker.internal:8811}"

# Generate firewall-domains.conf from config.json (GEN-01, GEN-02)
FIREWALL_CONF="$WORKSPACE_ROOT/.devcontainer/firewall-domains.conf"
CORE_DOMAINS=(
    # Package registries
    "registry.npmjs.org"
    "registry.npmjs.com"
    # Anthropic services
    "api.anthropic.com"
    "sentry.io"
    "statsig.anthropic.com"
    "statsig.com"
    # VS Code marketplace
    "marketplace.visualstudio.com"
    "gallerycdn.vsassets.io"
    "gallery.vsassets.io"
    "vsassets.io"
    "vscode.blob.core.windows.net"
    "update.code.visualstudio.com"
    # Debian repositories
    "deb.debian.org"
    "security.debian.org"
    # GitHub (IP ranges handled separately by init-firewall.sh)
    "github.com"
    "objects.githubusercontent.com"
    "uploads.github.com"
    "codeload.github.com"
    # Cloudflare
    "api.cloudflare.com"
    "dash.cloudflare.com"
    "workers.dev"
    # Python packages
    "pypi.python.org"
    "pypi.org"
    "files.pythonhosted.org"
    # Other
    "storage.googleapis.com"
    "json.schemastore.org"
    # OpenAI — API, auth, and platform (Codex CLI + API usage)
    "api.openai.com"
    "auth.openai.com"
    "platform.openai.com"
    "chatgpt.com"
    # Google AI
    "generativelanguage.googleapis.com"
)

{
    echo "# Generated by install-agent-config.sh — do not edit manually"
    echo "# Core domains (always present)"
    printf '%s\n' "${CORE_DOMAINS[@]}"
    echo ""
    echo "# Extra domains from config.json"
} > "$FIREWALL_CONF"

# Append extra_domains from config.json
if [ -f "$CONFIG_FILE" ]; then
    EXTRA_LIST=$(jq -r '.firewall.extra_domains // [] | .[]' "$CONFIG_FILE" 2>/dev/null || true)
    if [ -n "$EXTRA_LIST" ]; then
        echo "$EXTRA_LIST" >> "$FIREWALL_CONF"
    fi
fi

# Generate per-publisher VS Code CDN domains from devcontainer.json extensions
DEVCONTAINER_JSON="$WORKSPACE_ROOT/.devcontainer/devcontainer.json"
if [ -f "$DEVCONTAINER_JSON" ]; then
    PUBLISHERS=$(jq -r '.customizations.vscode.extensions // [] | .[] | split(".")[0]' "$DEVCONTAINER_JSON" 2>/dev/null | sort -u || true)
    if [ -n "$PUBLISHERS" ]; then
        {
            echo ""
            echo "# VS Code extension publisher CDN domains (auto-generated)"
            while IFS= read -r pub; do
                echo "${pub}.gallerycdn.vsassets.io"
                echo "${pub}.gallery.vsassets.io"
            done <<< "$PUBLISHERS"
        } >> "$FIREWALL_CONF"
    fi
fi

DOMAIN_COUNT=$(grep -c '^[^#]' "$FIREWALL_CONF" | tr -d '[:space:]')
echo "[install] Generated firewall-domains.conf with $DOMAIN_COUNT domain(s)"

# Generate .vscode/settings.json from config.json (GEN-03)
VSCODE_DIR="$WORKSPACE_ROOT/.vscode"
mkdir -p "$VSCODE_DIR"

# Read git scan paths from config.json
GIT_SCAN_PATHS='[".", "gitprojects/adventure-alerts"]'
if [ -f "$CONFIG_FILE" ]; then
    CONFIGURED_PATHS=$(jq -r '.vscode.git_scan_paths // []' "$CONFIG_FILE" 2>/dev/null || echo "[]")
    # If configured paths is non-empty array, use it; otherwise auto-detect
    PATH_COUNT=$(echo "$CONFIGURED_PATHS" | jq 'length' 2>/dev/null || echo "0")
    if [ "$PATH_COUNT" -gt 0 ]; then
        # User specified paths — prepend "." (workspace root) if not present
        GIT_SCAN_PATHS=$(echo "$CONFIGURED_PATHS" | jq '. as $paths | if (. | index(".")) then $paths else ["."] + $paths end')
    else
        # Auto-detect: find .git directories under gitprojects/
        DETECTED='["."]'
        if [ -d "$WORKSPACE_ROOT/gitprojects" ]; then
            for git_dir in "$WORKSPACE_ROOT/gitprojects"/*/.git; do
                if [ -d "$git_dir" ]; then
                    project_name=$(basename "$(dirname "$git_dir")")
                    DETECTED=$(echo "$DETECTED" | jq --arg p "gitprojects/$project_name" '. + [$p]')
                fi
            done
        fi
        GIT_SCAN_PATHS="$DETECTED"
    fi
fi

jq -n --argjson paths "$GIT_SCAN_PATHS" '{"git.scanRepositories": $paths}' > "$VSCODE_DIR/settings.json"
echo "[install] Generated .vscode/settings.json with $(echo "$GIT_SCAN_PATHS" | jq 'length') scan path(s)"

# Create directories (idempotent)
mkdir -p "$CLAUDE_DIR/skills"
mkdir -p "$CLAUDE_DIR/hooks"
mkdir -p "$CLAUDE_DIR/agents"
mkdir -p "$CLAUDE_DIR/commands"
mkdir -p /home/node/.codex

# Generate Codex CLI config.toml
CODEX_MODEL="gpt-5.3-codex"
if [ -f "$CONFIG_FILE" ]; then
    CONFIGURED_MODEL=$(jq -r '.codex.model // ""' "$CONFIG_FILE" 2>/dev/null || echo "")
    if [ -n "$CONFIGURED_MODEL" ]; then
        CODEX_MODEL="$CONFIGURED_MODEL"
    fi
fi
{
    echo "# Generated by install-agent-config.sh — do not edit manually"
    echo "model = \"$CODEX_MODEL\""
    echo 'cli_auth_credentials_store = "file"'
    echo 'approval_policy = "never"'
    echo 'sandbox_mode = "danger-full-access"'
    echo ""
    echo '[projects."/workspace"]'
    echo 'trust_level = "trusted"'
} > /home/node/.codex/config.toml
echo "[install] Generated Codex config.toml (model: $CODEX_MODEL)"

# Copy skills from agent-config to runtime location (AGT-03)
SKILLS_COUNT=0
if [ -d "$AGENT_CONFIG_DIR/skills" ]; then
    cp -r "$AGENT_CONFIG_DIR/skills/"* "$CLAUDE_DIR/skills/" 2>/dev/null || true
    SKILLS_COUNT=$(find "$AGENT_CONFIG_DIR/skills" -maxdepth 1 -mindepth 1 -type d 2>/dev/null | wc -l)
    echo "[install] Copied $SKILLS_COUNT skill(s) to $CLAUDE_DIR/skills/"
fi

# Copy hooks from agent-config to runtime location (AGT-04)
HOOKS_COUNT=0
if [ -d "$AGENT_CONFIG_DIR/hooks" ]; then
    cp "$AGENT_CONFIG_DIR/hooks/"* "$CLAUDE_DIR/hooks/" 2>/dev/null || true
    HOOKS_COUNT=$(find "$AGENT_CONFIG_DIR/hooks" -maxdepth 1 -type f 2>/dev/null | wc -l)
    echo "[install] Copied $HOOKS_COUNT hook(s) to $CLAUDE_DIR/hooks/"
fi

# Copy commands from agent-config, non-destructive — don't overwrite GSD (AGT-05)
COMMANDS_COUNT=0
if [ -d "$AGENT_CONFIG_DIR/commands" ]; then
    cp -rn "$AGENT_CONFIG_DIR/commands/"* "$CLAUDE_DIR/commands/" 2>/dev/null || true
    COMMANDS_COUNT=$(find "$AGENT_CONFIG_DIR/commands" -maxdepth 1 -mindepth 1 2>/dev/null | wc -l)
    echo "[install] Copied $COMMANDS_COUNT command source(s) to $CLAUDE_DIR/commands/ (non-destructive)"
fi

# Generate settings.local.json from template
if [ -f "$SETTINGS_TEMPLATE" ]; then
    sed -e "s|{{LANGFUSE_HOST}}|$LANGFUSE_HOST|g" \
        -e "s|{{LANGFUSE_PUBLIC_KEY}}|$LANGFUSE_PUBLIC_KEY|g" \
        -e "s|{{LANGFUSE_SECRET_KEY}}|$LANGFUSE_SECRET_KEY|g" \
        "$SETTINGS_TEMPLATE" > "$CLAUDE_DIR/settings.local.json"
    echo "[install] Generated settings.local.json"
else
    echo "[install] WARNING: settings.json.template not found — skipping settings generation"
fi

# Seed settings.json with permissions so GSD installer has a valid file to merge into.
# Final settings enforcement happens AFTER GSD installation (which modifies this file).
if [ ! -f "$CLAUDE_DIR/settings.json" ]; then
    jq -n '{"permissions":{"allow":[],"deny":[],"additionalDirectories":[],"defaultMode":"bypassPermissions"}}' \
        > "$CLAUDE_DIR/settings.json"
fi

# Restore Claude credentials (if available)
if [ -f "$SECRETS_FILE" ]; then
    CLAUDE_CREDS=$(jq -e '.claude.credentials // {}' "$SECRETS_FILE" 2>/dev/null || echo "{}")
    # Check if credentials object is non-empty
    if [ "$CLAUDE_CREDS" != "{}" ] && [ "$CLAUDE_CREDS" != "null" ]; then
        echo "$CLAUDE_CREDS" > "$CLAUDE_DIR/.credentials.json"
        chmod 600 "$CLAUDE_DIR/.credentials.json"
        CREDS_STATUS="restored"
        echo "[install] Claude credentials restored"

        # Mark onboarding complete, dismiss effort callout, prevent VS Code extension auto-install
        CLAUDE_JSON="/home/node/.claude.json"
        if [ ! -f "$CLAUDE_JSON" ]; then
            jq -n '{
                "hasCompletedOnboarding": true,
                "theme": "dark",
                "effortCalloutDismissed": true,
                "officialMarketplaceAutoInstallAttempted": true,
                "officialMarketplaceAutoInstalled": true
            }' > "$CLAUDE_JSON"
        else
            jq '.hasCompletedOnboarding = true | .effortCalloutDismissed = true | .officialMarketplaceAutoInstallAttempted = true | .officialMarketplaceAutoInstalled = true' \
                "$CLAUDE_JSON" > "$CLAUDE_JSON.tmp" \
                && mv "$CLAUDE_JSON.tmp" "$CLAUDE_JSON"
        fi
    else
        echo "[install] Claude credentials not found — manual login required after first start"
    fi
else
    echo "[install] Claude credentials not found — manual login required after first start"
fi

# Restore Codex CLI credentials (if available)
if [ -f "$SECRETS_FILE" ]; then
    CODEX_AUTH=$(jq -e '.codex.auth // {}' "$SECRETS_FILE" 2>/dev/null || echo "{}")
    if [ "$CODEX_AUTH" != "{}" ] && [ "$CODEX_AUTH" != "null" ]; then
        echo "$CODEX_AUTH" > /home/node/.codex/auth.json
        chmod 600 /home/node/.codex/auth.json
        CODEX_CREDS_STATUS="restored"
        echo "[install] Codex credentials restored"
    else
        echo "[install] Codex credentials not found — manual login required after first start"
    fi
else
    echo "[install] Codex credentials not found — manual login required after first start"
fi

# Restore git identity from secrets.json
if [ -f "$SECRETS_FILE" ]; then
    GIT_NAME=$(jq -r '.git.name // ""' "$SECRETS_FILE" 2>/dev/null || echo "")
    GIT_EMAIL=$(jq -r '.git.email // ""' "$SECRETS_FILE" 2>/dev/null || echo "")
    if [ -n "$GIT_NAME" ] && [ -n "$GIT_EMAIL" ]; then
        git config --global user.name "$GIT_NAME"
        git config --global user.email "$GIT_EMAIL"
        GIT_IDENTITY_STATUS="$GIT_NAME <$GIT_EMAIL>"
        echo "[install] Git identity restored: $GIT_NAME <$GIT_EMAIL>"
    else
        echo "[install] Git identity not found in secrets.json — set manually or run save-secrets"
    fi
fi

# Generate .mcp.json from enabled MCP templates
if [ -f "$CONFIG_FILE" ]; then
    # Get list of enabled MCP servers
    ENABLED_SERVERS=$(jq -r '.mcp_servers | to_entries[] | select(.value.enabled == true) | .key' "$CONFIG_FILE" 2>/dev/null || echo "")

    if [ -n "$ENABLED_SERVERS" ]; then
        # Build combined MCP config
        MCP_JSON='{"mcpServers":{}}'

        for SERVER in $ENABLED_SERVERS; do
            TEMPLATE_FILE="$MCP_TEMPLATES_DIR/${SERVER}.json"
            if [ -f "$TEMPLATE_FILE" ]; then
                # Hydrate template and merge into combined config
                HYDRATED=$(sed "s|{{MCP_GATEWAY_URL}}|$MCP_GATEWAY_URL|g" "$TEMPLATE_FILE")
                MCP_JSON=$(echo "$MCP_JSON" | jq --argjson server "{\"$SERVER\": $HYDRATED}" '.mcpServers += $server')
                MCP_COUNT=$((MCP_COUNT + 1))
            else
                echo "[install] WARNING: Template $TEMPLATE_FILE not found for enabled server $SERVER"
            fi
        done

        echo "$MCP_JSON" > "$CLAUDE_DIR/.mcp.json"
        echo "[install] Generated .mcp.json with $MCP_COUNT server(s)"
    else
        # No enabled servers, create default with mcp-gateway
        echo '{"mcpServers":{"mcp-gateway":{"type":"sse","url":"'"$MCP_GATEWAY_URL"'/sse"}}}' > "$CLAUDE_DIR/.mcp.json"
        MCP_COUNT=1
        echo "[install] Generated .mcp.json with 1 server(s) (default)"
    fi
else
    # No config.json, create default with mcp-gateway
    echo '{"mcpServers":{"mcp-gateway":{"type":"sse","url":"'"$MCP_GATEWAY_URL"'/sse"}}}' > "$CLAUDE_DIR/.mcp.json"
    MCP_COUNT=1
    echo "[install] Generated .mcp.json with 1 server(s) (default)"
fi

# Generate infra/.env from secrets.json if infra section exists
INFRA_ENV_STATUS="skipped — no infra secrets"
if [ -f "$SECRETS_FILE" ]; then
    HAS_INFRA=$(jq -e '.infra.postgres_password // empty' "$SECRETS_FILE" 2>/dev/null && echo "yes" || echo "")
    if [ -n "$HAS_INFRA" ]; then
        if command -v langfuse-setup &>/dev/null; then
            langfuse-setup --generate-env 2>/dev/null && INFRA_ENV_STATUS="generated" || INFRA_ENV_STATUS="failed"
            echo "[install] infra/.env: $INFRA_ENV_STATUS"
        else
            echo "[install] WARNING: langfuse-setup not on PATH — skipping .env generation"
        fi
    fi
fi

# Detect unresolved {{PLACEHOLDER}} tokens in generated files (GEN-06)
UNRESOLVED=""
for generated_file in "$CLAUDE_DIR/settings.local.json" "$CLAUDE_DIR/.mcp.json"; do
    if [ -f "$generated_file" ]; then
        tokens=$(grep -oP '\{\{[A-Z_]+\}\}' "$generated_file" 2>/dev/null || true)
        if [ -n "$tokens" ]; then
            UNRESOLVED="$UNRESOLVED $tokens"
            # Replace unresolved tokens with empty strings
            sed -i 's/{{[A-Z_]*}}//g' "$generated_file"
        fi
    fi
done
if [ -n "$UNRESOLVED" ]; then
    echo "[install] WARNING: Unresolved placeholders replaced with empty strings:$UNRESOLVED"
fi

# Install GSD framework
if [ -d "$CLAUDE_DIR/commands/gsd" ] && [ "$(ls -A "$CLAUDE_DIR/commands/gsd" 2>/dev/null)" ]; then
    echo "[install] GSD: already installed, skipping"
    # Count existing installation
    GSD_COMMANDS=$(find "$CLAUDE_DIR/commands/gsd" -name "*.md" 2>/dev/null | wc -l || echo 0)
    GSD_AGENTS=$(find "$CLAUDE_DIR/agents" -name "*.md" 2>/dev/null | wc -l || echo 0)
else
    echo "[install] Installing GSD framework..."
    if npx get-shit-done-cc --claude --global > /dev/null 2>&1; then
        echo "[install] GSD framework installed"
        # Count after installation
        GSD_COMMANDS=$(find "$CLAUDE_DIR/commands/gsd" -name "*.md" 2>/dev/null | wc -l || echo 0)
        GSD_AGENTS=$(find "$CLAUDE_DIR/agents" -name "*.md" 2>/dev/null | wc -l || echo 0)
    else
        echo "[install] WARNING: GSD installation failed"
        GSD_COMMANDS=0
        GSD_AGENTS=0
    fi
fi

# Enforce required settings.json values AFTER GSD (which modifies the file).
# This is the last write to settings.json — bypassPermissions, model, effort, skip prompt.
jq '.permissions.defaultMode = "bypassPermissions" | .effortLevel = "high" | .model = "opus" | .skipDangerousModePermissionPrompt = true' \
    "$CLAUDE_DIR/settings.json" > "$CLAUDE_DIR/settings.json.tmp" \
    && mv "$CLAUDE_DIR/settings.json.tmp" "$CLAUDE_DIR/settings.json"
echo "[install] Enforced settings.json (bypassPermissions, opus, effortLevel: high)"

# Print summary
echo "[install] --- Summary ---"
echo "[install] Config: $CONFIG_STATUS"
echo "[install] Secrets: $SECRETS_STATUS"
echo "[install] Settings: generated"
echo "[install] Credentials (Claude): $CREDS_STATUS"
echo "[install] Credentials (Codex): $CODEX_CREDS_STATUS"
echo "[install] Git identity: $GIT_IDENTITY_STATUS"
echo "[install] Skills: $SKILLS_COUNT skill(s)"
echo "[install] Hooks: $HOOKS_COUNT hook(s)"
echo "[install] Commands: $COMMANDS_COUNT command source(s)"
echo "[install] MCP: $MCP_COUNT server(s)"
echo "[install] Infra .env: $INFRA_ENV_STATUS"
echo "[install] GSD: $GSD_COMMANDS commands + $GSD_AGENTS agents"
echo "[install] Done."
