#!/bin/bash
set -euo pipefail

# install-agent-config.sh
# Reads config.json and secrets.json, hydrates templates, installs GSD framework,
# restores credentials, and prints a summary.
# Safe to run multiple times (naturally idempotent).

# Constants and paths
WORKSPACE_ROOT="/workspace"
CONFIG_FILE="$WORKSPACE_ROOT/config.json"
SECRETS_FILE="$WORKSPACE_ROOT/secrets.json"
AGENT_CONFIG_DIR="$WORKSPACE_ROOT/agent-config"
CLAUDE_DIR="${CLAUDE_CONFIG_DIR:-/home/node/.claude}"
SETTINGS_TEMPLATE="$AGENT_CONFIG_DIR/settings.json.template"
MCP_TEMPLATES_DIR="$AGENT_CONFIG_DIR/mcp-templates"

# JSON validation helper
validate_json() {
    local file="$1"
    local label="$2"
    if ! jq empty < "$file" &>/dev/null; then
        echo "[install] ERROR: $label is not valid JSON — skipping"
        return 1
    fi
    return 0
}

# Initialize counters for summary
CONFIG_STATUS="defaults — config.json not found"
SECRETS_STATUS="empty placeholders — secrets.json not found"
CREDS_STATUS="missing — manual login required"
CODEX_CREDS_STATUS="missing — manual login required"
GIT_IDENTITY_STATUS="not set"
MCP_COUNT=0
GSD_COMMANDS=0
GSD_AGENTS=0
COMMANDS_COUNT=0
PLUGIN_INSTALLED=0
PLUGIN_SKIPPED=0
PLUGIN_HOOKS='{}'
PLUGIN_ENV='{}'
PLUGIN_MCP='{}'
PLUGIN_WARNINGS=0

# Load config.json (or use defaults)
if [ -f "$CONFIG_FILE" ]; then
    if validate_json "$CONFIG_FILE" "config.json"; then
        CONFIG_STATUS="loaded"
        LANGFUSE_HOST=$(jq -r '.langfuse.host // "http://host.docker.internal:3052"' "$CONFIG_FILE")
        EXTRA_DOMAINS=$(jq -r '.firewall.extra_domains // [] | join(" ")' "$CONFIG_FILE")
    else
        LANGFUSE_HOST="http://host.docker.internal:3052"
        EXTRA_DOMAINS=""
    fi
else
    echo "[install] config.json not found — using defaults"
    LANGFUSE_HOST="http://host.docker.internal:3052"
    EXTRA_DOMAINS=""
fi

# Load secrets.json (or use empty placeholders)
if [ -f "$SECRETS_FILE" ]; then
    if validate_json "$SECRETS_FILE" "secrets.json"; then
        SECRETS_STATUS="loaded"
        LANGFUSE_PUBLIC_KEY=$(jq -r '.infra.langfuse_project_public_key // ""' "$SECRETS_FILE")
        LANGFUSE_SECRET_KEY=$(jq -r '.infra.langfuse_project_secret_key // ""' "$SECRETS_FILE")

        # Check for missing individual secrets
        if [ -z "$LANGFUSE_PUBLIC_KEY" ]; then
            echo "[install] secrets.json: infra.langfuse_project_public_key missing — tracing will not work"
        fi
        if [ -z "$LANGFUSE_SECRET_KEY" ]; then
            echo "[install] secrets.json: infra.langfuse_project_secret_key missing — tracing will not work"
        fi
    else
        LANGFUSE_PUBLIC_KEY=""
        LANGFUSE_SECRET_KEY=""
    fi
else
    echo "[install] secrets.json not found — using empty placeholders"
    LANGFUSE_PUBLIC_KEY=""
    LANGFUSE_SECRET_KEY=""
fi

# Get MCP Gateway URL from environment or default
MCP_GATEWAY_URL="${MCP_GATEWAY_URL:-http://host.docker.internal:8811}"

# Generate firewall-domains.conf from config.json (GEN-01, GEN-02)
FIREWALL_CONF="$WORKSPACE_ROOT/.devcontainer/firewall-domains.conf"
CORE_DOMAINS=(
    # Package registries
    "registry.npmjs.org"
    "registry.npmjs.com"
    # Anthropic services
    "api.anthropic.com"
    "sentry.io"
    "statsig.anthropic.com"
    "statsig.com"
    # VS Code marketplace
    "marketplace.visualstudio.com"
    "gallerycdn.vsassets.io"
    "gallery.vsassets.io"
    "vsassets.io"
    "vscode.blob.core.windows.net"
    "update.code.visualstudio.com"
    # Debian repositories
    "deb.debian.org"
    "security.debian.org"
    # GitHub (IP ranges handled separately by init-firewall.sh)
    "github.com"
    "objects.githubusercontent.com"
    "uploads.github.com"
    "codeload.github.com"
    # Cloudflare
    "api.cloudflare.com"
    "dash.cloudflare.com"
    "workers.dev"
    # Python packages
    "pypi.python.org"
    "pypi.org"
    "files.pythonhosted.org"
    # Other
    "storage.googleapis.com"
    "json.schemastore.org"
    # OpenAI — API, auth, and platform (Codex CLI + API usage)
    "api.openai.com"
    "auth.openai.com"
    "platform.openai.com"
    "chatgpt.com"
    # Google AI
    "generativelanguage.googleapis.com"
)

{
    echo "# Generated by install-agent-config.sh — do not edit manually"
    echo "# Core domains (always present)"
    printf '%s\n' "${CORE_DOMAINS[@]}"
    echo ""
    echo "# Extra domains from config.json"
} > "$FIREWALL_CONF"

# Append extra_domains from config.json
if [ -f "$CONFIG_FILE" ]; then
    EXTRA_LIST=$(jq -r '.firewall.extra_domains // [] | .[]' "$CONFIG_FILE" 2>/dev/null || true)
    if [ -n "$EXTRA_LIST" ]; then
        echo "$EXTRA_LIST" >> "$FIREWALL_CONF"
    fi
fi

# Generate per-publisher VS Code CDN domains from devcontainer.json extensions
DEVCONTAINER_JSON="$WORKSPACE_ROOT/.devcontainer/devcontainer.json"
if [ -f "$DEVCONTAINER_JSON" ]; then
    PUBLISHERS=$(jq -r '.customizations.vscode.extensions // [] | .[] | split(".")[0]' "$DEVCONTAINER_JSON" 2>/dev/null | sort -u || true)
    if [ -n "$PUBLISHERS" ]; then
        {
            echo ""
            echo "# VS Code extension publisher CDN domains (auto-generated)"
            while IFS= read -r pub; do
                echo "${pub}.gallerycdn.vsassets.io"
                echo "${pub}.gallery.vsassets.io"
            done <<< "$PUBLISHERS"
        } >> "$FIREWALL_CONF"
    fi
fi

DOMAIN_COUNT=$(grep -c '^[^#]' "$FIREWALL_CONF" | tr -d '[:space:]')
echo "[install] Generated firewall-domains.conf with $DOMAIN_COUNT domain(s)"

# Generate .vscode/settings.json from config.json (GEN-03)
VSCODE_DIR="$WORKSPACE_ROOT/.vscode"
mkdir -p "$VSCODE_DIR"

# Read git scan paths from config.json
GIT_SCAN_PATHS='[".", "gitprojects/adventure-alerts"]'
if [ -f "$CONFIG_FILE" ]; then
    CONFIGURED_PATHS=$(jq -r '.vscode.git_scan_paths // []' "$CONFIG_FILE" 2>/dev/null || echo "[]")
    # If configured paths is non-empty array, use it; otherwise auto-detect
    PATH_COUNT=$(echo "$CONFIGURED_PATHS" | jq 'length' 2>/dev/null || echo "0")
    if [ "$PATH_COUNT" -gt 0 ]; then
        # User specified paths — prepend "." (workspace root) if not present
        GIT_SCAN_PATHS=$(echo "$CONFIGURED_PATHS" | jq '. as $paths | if (. | index(".")) then $paths else ["."] + $paths end')
    else
        # Auto-detect: find .git directories under gitprojects/
        DETECTED='["."]'
        if [ -d "$WORKSPACE_ROOT/gitprojects" ]; then
            for git_dir in "$WORKSPACE_ROOT/gitprojects"/*/.git; do
                if [ -d "$git_dir" ]; then
                    project_name=$(basename "$(dirname "$git_dir")")
                    DETECTED=$(echo "$DETECTED" | jq --arg p "gitprojects/$project_name" '. + [$p]')
                fi
            done
        fi
        GIT_SCAN_PATHS="$DETECTED"
    fi
fi

jq -n --argjson paths "$GIT_SCAN_PATHS" '{"git.scanRepositories": $paths}' > "$VSCODE_DIR/settings.json"
echo "[install] Generated .vscode/settings.json with $(echo "$GIT_SCAN_PATHS" | jq 'length') scan path(s)"

# Create directories (idempotent)
mkdir -p "$CLAUDE_DIR/skills"
mkdir -p "$CLAUDE_DIR/hooks"
mkdir -p "$CLAUDE_DIR/agents"
mkdir -p "$CLAUDE_DIR/commands"
mkdir -p /home/node/.codex

# Generate Codex CLI config.toml
CODEX_MODEL="gpt-5.3-codex"
if [ -f "$CONFIG_FILE" ]; then
    CONFIGURED_MODEL=$(jq -r '.codex.model // ""' "$CONFIG_FILE" 2>/dev/null || echo "")
    if [ -n "$CONFIGURED_MODEL" ]; then
        CODEX_MODEL="$CONFIGURED_MODEL"
    fi
fi
{
    echo "# Generated by install-agent-config.sh — do not edit manually"
    echo "model = \"$CODEX_MODEL\""
    echo 'cli_auth_credentials_store = "file"'
    echo 'approval_policy = "never"'
    echo 'sandbox_mode = "danger-full-access"'
    echo ""
    echo '[features]'
    echo 'skills = true'
    echo ""
    echo '[projects."/workspace"]'
    echo 'trust_level = "trusted"'
} > /home/node/.codex/config.toml
echo "[install] Generated Codex config.toml (model: $CODEX_MODEL)"

# Copy skills from agent-config to runtime location (AGT-03) - Cross-agent support
SKILLS_COUNT=0
if [ -d "$AGENT_CONFIG_DIR/skills" ]; then
    # Create Codex skills directory
    mkdir -p /home/node/.codex/skills

    # Copy to both Claude and Codex
    cp -r "$AGENT_CONFIG_DIR/skills/"* "$CLAUDE_DIR/skills/" 2>/dev/null || true
    cp -r "$AGENT_CONFIG_DIR/skills/"* /home/node/.codex/skills/ 2>/dev/null || true

    SKILLS_COUNT=$(find "$AGENT_CONFIG_DIR/skills" -maxdepth 1 -mindepth 1 -type d 2>/dev/null | wc -l)
    echo "[install] Skills: $SKILLS_COUNT skill(s) -> Claude + Codex"
fi

# Copy hooks from agent-config to runtime location (AGT-04)
HOOKS_COUNT=0
if [ -d "$AGENT_CONFIG_DIR/hooks" ]; then
    cp "$AGENT_CONFIG_DIR/hooks/"* "$CLAUDE_DIR/hooks/" 2>/dev/null || true
    HOOKS_COUNT=$(find "$AGENT_CONFIG_DIR/hooks" -maxdepth 1 -type f 2>/dev/null | wc -l)
    echo "[install] Copied $HOOKS_COUNT hook(s) to $CLAUDE_DIR/hooks/"
fi

# Copy standalone commands from agent-config to runtime location
COMMANDS_COUNT=0
if [ -d "$AGENT_CONFIG_DIR/commands" ]; then
    for cmd_file in "$AGENT_CONFIG_DIR/commands/"*.md; do
        # Skip if no .md files exist
        [ -f "$cmd_file" ] || continue

        # Get filename
        cmd_name=$(basename "$cmd_file")

        # Protect GSD namespace (unlikely but safety check)
        if [ "$cmd_name" = "gsd" ]; then
            echo "[install] WARNING: Skipping standalone command 'gsd' (reserved for GSD framework)"
            continue
        fi

        # Copy to commands directory
        cp "$cmd_file" "$CLAUDE_DIR/commands/"
        COMMANDS_COUNT=$((COMMANDS_COUNT + 1))
    done
    if [ $COMMANDS_COUNT -gt 0 ]; then
        echo "[install] Commands: $COMMANDS_COUNT standalone command(s)"
    fi
fi

# Hydrate settings template (merged into settings.json later, after GSD install)
if [ -f "$SETTINGS_TEMPLATE" ]; then
    HYDRATED_SETTINGS=$(sed -e "s|{{LANGFUSE_HOST}}|$LANGFUSE_HOST|g" \
        -e "s|{{LANGFUSE_PUBLIC_KEY}}|$LANGFUSE_PUBLIC_KEY|g" \
        -e "s|{{LANGFUSE_SECRET_KEY}}|$LANGFUSE_SECRET_KEY|g" \
        "$SETTINGS_TEMPLATE")
    echo "[install] Hydrated settings template (will merge into settings.json)"
else
    HYDRATED_SETTINGS='{}'
    echo "[install] WARNING: settings.json.template not found — skipping settings generation"
fi

# Seed settings.json with permissions so GSD installer has a valid file to merge into.
# Final settings enforcement happens AFTER GSD installation (which modifies this file).
if [ ! -f "$CLAUDE_DIR/settings.json" ]; then
    jq -n '{"permissions":{"allow":[],"deny":[],"additionalDirectories":[],"defaultMode":"bypassPermissions"}}' \
        > "$CLAUDE_DIR/settings.json"
fi

# --- Plugin Installation ---
if [ -d "$AGENT_CONFIG_DIR/plugins" ]; then
    for plugin_dir in "$AGENT_CONFIG_DIR/plugins"/*/; do
        # Guard against empty directory
        [ -d "$plugin_dir" ] || continue

        plugin_name=$(basename "$plugin_dir")
        MANIFEST="$plugin_dir/plugin.json"

        # Reset per-plugin counters
        plugin_skills=0
        plugin_hooks_count=0
        plugin_cmds=0
        plugin_agents=0

        # Check if plugin is enabled in config.json (default: true)
        plugin_enabled="true"
        if [ -f "$CONFIG_FILE" ]; then
            plugin_enabled=$(jq -r --arg name "$plugin_name" '.plugins[$name].enabled // true' "$CONFIG_FILE" 2>/dev/null || echo "true")
        fi

        # Skip if disabled
        if [ "$plugin_enabled" = "false" ]; then
            echo "[install] Plugin '$plugin_name': skipped (disabled)"
            PLUGIN_SKIPPED=$((PLUGIN_SKIPPED + 1))
            continue
        fi

        # Validate plugin.json exists
        if [ ! -f "$MANIFEST" ]; then
            echo "[install] Plugin '$plugin_name': skipped (no plugin.json)"
            PLUGIN_SKIPPED=$((PLUGIN_SKIPPED + 1))
            continue
        fi

        # Validate plugin.json is valid JSON
        if ! validate_json "$MANIFEST" "plugins/$plugin_name/plugin.json"; then
            PLUGIN_SKIPPED=$((PLUGIN_SKIPPED + 1))
            continue
        fi

        # Validate plugin name matches directory name
        manifest_name=$(jq -r '.name // ""' "$MANIFEST" 2>/dev/null)
        if [ "$manifest_name" != "$plugin_name" ]; then
            echo "[install] WARNING: Plugin '$plugin_name' manifest name '$manifest_name' does not match directory name — skipping"
            PLUGIN_WARNINGS=$((PLUGIN_WARNINGS + 1))
            PLUGIN_SKIPPED=$((PLUGIN_SKIPPED + 1))
            continue
        fi

        # Plugin is valid and enabled — proceed to file copying

        # Copy skills (cross-agent: Claude + Codex)
        if [ -d "$plugin_dir/skills" ]; then
            cp -r "$plugin_dir/skills/"* "$CLAUDE_DIR/skills/" 2>/dev/null || true
            cp -r "$plugin_dir/skills/"* /home/node/.codex/skills/ 2>/dev/null || true
            plugin_skills=$(find "$plugin_dir/skills" -maxdepth 1 -mindepth 1 -type d 2>/dev/null | wc -l)
        fi

        # Copy hooks
        if [ -d "$plugin_dir/hooks" ]; then
            for hook_file in "$plugin_dir/hooks"/*; do
                [ -f "$hook_file" ] || continue
                cp "$hook_file" "$CLAUDE_DIR/hooks/"
            done
            plugin_hooks_count=$(find "$plugin_dir/hooks" -maxdepth 1 -type f 2>/dev/null | wc -l)
        fi

        # Copy commands (with GSD protection)
        if [ -d "$plugin_dir/commands" ]; then
            # Check for GSD directory conflict
            if [ -d "$plugin_dir/commands/gsd" ]; then
                echo "[install] ERROR: Plugin '$plugin_name' attempted to overwrite GSD-protected directory commands/gsd/ -- skipping"
                PLUGIN_WARNINGS=$((PLUGIN_WARNINGS + 1))
            fi
            for cmd_file in "$plugin_dir/commands"/*.md; do
                [ -f "$cmd_file" ] || continue
                cp "$cmd_file" "$CLAUDE_DIR/commands/"
            done
            plugin_cmds=$(find "$plugin_dir/commands" -maxdepth 1 -name "*.md" -type f 2>/dev/null | wc -l)
        fi

        # Copy agents (with GSD protection)
        if [ -d "$plugin_dir/agents" ]; then
            for agent_file in "$plugin_dir/agents"/*.md; do
                [ -f "$agent_file" ] || continue
                agent_name=$(basename "$agent_file")
                if [[ "$agent_name" =~ ^gsd- ]]; then
                    echo "[install] ERROR: Plugin '$plugin_name' attempted to overwrite GSD-protected file agents/$agent_name -- skipping"
                    PLUGIN_WARNINGS=$((PLUGIN_WARNINGS + 1))
                    continue
                fi
                cp "$agent_file" "$CLAUDE_DIR/agents/"
            done
            plugin_agents=$(find "$plugin_dir/agents" -maxdepth 1 -name "*.md" -type f 2>/dev/null | wc -l)
        fi

        # Accumulate hook registrations
        MANIFEST_HOOKS=$(jq -r '.hooks // {}' "$MANIFEST" 2>/dev/null)
        if [ "$MANIFEST_HOOKS" != "{}" ] && [ "$MANIFEST_HOOKS" != "null" ]; then
            PLUGIN_HOOKS=$(jq -n --argjson acc "$PLUGIN_HOOKS" --argjson new "$MANIFEST_HOOKS" '
                $new | to_entries | reduce .[] as $entry ($acc;
                    .[$entry.key] = ((.[$entry.key] // []) + $entry.value)
                )
            ' 2>/dev/null || echo "$PLUGIN_HOOKS")
        fi

        # Accumulate environment variables with conflict detection
        MANIFEST_ENV=$(jq -r '.env // {}' "$MANIFEST" 2>/dev/null)
        if [ "$MANIFEST_ENV" != "{}" ] && [ "$MANIFEST_ENV" != "null" ]; then
            # Check for conflicts: any key in MANIFEST_ENV that already exists in PLUGIN_ENV
            CONFLICTS=$(jq -n --argjson existing "$PLUGIN_ENV" --argjson new "$MANIFEST_ENV" '
                [$new | keys[] | select(. as $k | $existing | has($k))]
            ' 2>/dev/null)
            if [ "$CONFLICTS" != "[]" ] && [ -n "$CONFLICTS" ]; then
                echo "[install] WARNING: Plugin '$plugin_name' env var conflict: $CONFLICTS -- using earlier plugin's values"
                PLUGIN_WARNINGS=$((PLUGIN_WARNINGS + 1))
                # Only add non-conflicting keys
                PLUGIN_ENV=$(jq -n --argjson existing "$PLUGIN_ENV" --argjson new "$MANIFEST_ENV" '
                    $existing + ($new | to_entries | map(select(.key as $k | $existing | has($k) | not)) | from_entries)
                ' 2>/dev/null || echo "$PLUGIN_ENV")
            else
                PLUGIN_ENV=$(jq -n --argjson existing "$PLUGIN_ENV" --argjson new "$MANIFEST_ENV" '
                    $existing + $new
                ' 2>/dev/null || echo "$PLUGIN_ENV")
            fi

            # Apply config.json overrides (always take precedence)
            if [ -f "$CONFIG_FILE" ]; then
                CONFIG_ENV_OVERRIDES=$(jq -r --arg name "$plugin_name" '.plugins[$name].env // {}' "$CONFIG_FILE" 2>/dev/null || echo "{}")
                if [ "$CONFIG_ENV_OVERRIDES" != "{}" ]; then
                    PLUGIN_ENV=$(jq -n --argjson existing "$PLUGIN_ENV" --argjson overrides "$CONFIG_ENV_OVERRIDES" '
                        $existing * $overrides
                    ' 2>/dev/null || echo "$PLUGIN_ENV")
                fi
            fi
        fi

        # Accumulate MCP servers with source tagging
        MANIFEST_MCP=$(jq -r '.mcp_servers // {}' "$MANIFEST" 2>/dev/null || echo "{}")
        if [ "$MANIFEST_MCP" != "{}" ] && [ "$MANIFEST_MCP" != "null" ]; then
            # Tag each server with _source for traceability
            TAGGED_MCP=$(echo "$MANIFEST_MCP" | jq --arg plugin "$plugin_name" '
                to_entries | map(.value._source = "plugin:\($plugin)") | from_entries
            ' 2>/dev/null || echo "{}")
            if [ "$TAGGED_MCP" != "{}" ]; then
                PLUGIN_MCP=$(jq -n --argjson acc "$PLUGIN_MCP" --argjson new "$TAGGED_MCP" \
                    '$acc * $new' 2>/dev/null || echo "$PLUGIN_MCP")
            fi
        fi

        # Per-plugin detail logging
        detail_parts=()
        [ "${plugin_skills:-0}" -gt 0 ] && detail_parts+=("${plugin_skills} skill(s)")
        [ "${plugin_hooks_count:-0}" -gt 0 ] && detail_parts+=("${plugin_hooks_count} hook(s)")
        [ "${plugin_cmds:-0}" -gt 0 ] && detail_parts+=("${plugin_cmds} command(s)")
        [ "${plugin_agents:-0}" -gt 0 ] && detail_parts+=("${plugin_agents} agent(s)")

        # Count env vars from this plugin's manifest
        plugin_env_count=$(jq -r '.env // {} | length' "$MANIFEST" 2>/dev/null || echo "0")
        [ "$plugin_env_count" -gt 0 ] && detail_parts+=("${plugin_env_count} env var(s)")

        # Count MCP servers from this plugin's manifest
        plugin_mcp_count=$(echo "$MANIFEST_MCP" | jq 'if . == {} or . == null then 0 else length end' 2>/dev/null || echo "0")
        [ "$plugin_mcp_count" -gt 0 ] && detail_parts+=("${plugin_mcp_count} MCP server(s)")

        detail_str=$(IFS=", "; echo "${detail_parts[*]}")
        if [ -n "$detail_str" ]; then
            echo "[install] Plugin '$plugin_name': installed ($detail_str)"
        else
            echo "[install] Plugin '$plugin_name': installed (manifest only)"
        fi
        PLUGIN_INSTALLED=$((PLUGIN_INSTALLED + 1))

    done

    # Log plugin installation summary
    echo "[install] Plugins: $PLUGIN_INSTALLED installed, $PLUGIN_SKIPPED skipped"
fi

# --- Plugin registrations are merged into settings.json after GSD install ---

# Plugin installation recap
if [ "$PLUGIN_INSTALLED" -gt 0 ] || [ "$PLUGIN_SKIPPED" -gt 0 ]; then
    echo "[install] --- Plugin Recap ---"
    echo "[install] Plugins: $PLUGIN_INSTALLED installed, $PLUGIN_SKIPPED skipped"

    # Count total hook registrations
    TOTAL_HOOK_REGS=0
    if [ "$PLUGIN_HOOKS" != "{}" ]; then
        TOTAL_HOOK_REGS=$(echo "$PLUGIN_HOOKS" | jq '[.[] | length] | add // 0' 2>/dev/null || echo "0")
    fi
    echo "[install] Hook registrations: $TOTAL_HOOK_REGS"

    # Count total plugin env vars
    TOTAL_PLUGIN_ENV=0
    if [ "$PLUGIN_ENV" != "{}" ]; then
        TOTAL_PLUGIN_ENV=$(echo "$PLUGIN_ENV" | jq 'length' 2>/dev/null || echo "0")
    fi
    echo "[install] Plugin env vars: $TOTAL_PLUGIN_ENV"

    # Count total plugin MCP servers
    TOTAL_PLUGIN_MCP=0
    if [ "$PLUGIN_MCP" != "{}" ]; then
        TOTAL_PLUGIN_MCP=$(echo "$PLUGIN_MCP" | jq 'length' 2>/dev/null || echo "0")
    fi
    echo "[install] Plugin MCP servers: $TOTAL_PLUGIN_MCP"

    if [ "$PLUGIN_WARNINGS" -gt 0 ]; then
        echo "[install] Warnings: $PLUGIN_WARNINGS"
    fi
fi

# Restore Claude credentials (if available)
if [ -f "$SECRETS_FILE" ]; then
    CLAUDE_CREDS=$(jq -e '.claude.credentials // {}' "$SECRETS_FILE" 2>/dev/null || echo "{}")
    # Check if credentials object is non-empty
    if [ "$CLAUDE_CREDS" != "{}" ] && [ "$CLAUDE_CREDS" != "null" ]; then
        echo "$CLAUDE_CREDS" > "$CLAUDE_DIR/.credentials.json"
        chmod 600 "$CLAUDE_DIR/.credentials.json"
        CREDS_STATUS="restored"
        echo "[install] Claude credentials restored"

        # Mark onboarding complete, dismiss effort callout, prevent VS Code extension auto-install
        CLAUDE_JSON="/home/node/.claude.json"
        if [ ! -f "$CLAUDE_JSON" ]; then
            jq -n '{
                "hasCompletedOnboarding": true,
                "theme": "dark",
                "effortCalloutDismissed": true,
                "officialMarketplaceAutoInstallAttempted": true,
                "officialMarketplaceAutoInstalled": true,
                "hasIdeOnboardingBeenShown": {"vscode": true}
            }' > "$CLAUDE_JSON"
        else
            jq '.hasCompletedOnboarding = true | .effortCalloutDismissed = true | .officialMarketplaceAutoInstallAttempted = true | .officialMarketplaceAutoInstalled = true | .hasIdeOnboardingBeenShown.vscode = true' \
                "$CLAUDE_JSON" > "$CLAUDE_JSON.tmp" \
                && mv "$CLAUDE_JSON.tmp" "$CLAUDE_JSON"
        fi
    else
        echo "[install] Claude credentials not found — manual login required after first start"
    fi
else
    echo "[install] Claude credentials not found — manual login required after first start"
fi

# Restore Codex CLI credentials (if available)
if [ -f "$SECRETS_FILE" ]; then
    CODEX_AUTH=$(jq -e '.codex.auth // {}' "$SECRETS_FILE" 2>/dev/null || echo "{}")
    if [ "$CODEX_AUTH" != "{}" ] && [ "$CODEX_AUTH" != "null" ]; then
        echo "$CODEX_AUTH" > /home/node/.codex/auth.json
        chmod 600 /home/node/.codex/auth.json
        CODEX_CREDS_STATUS="restored"
        echo "[install] Codex credentials restored"
    else
        echo "[install] Codex credentials not found — manual login required after first start"
    fi
else
    echo "[install] Codex credentials not found — manual login required after first start"
fi

# Restore git identity from secrets.json
if [ -f "$SECRETS_FILE" ]; then
    GIT_NAME=$(jq -r '.git.name // ""' "$SECRETS_FILE" 2>/dev/null || echo "")
    GIT_EMAIL=$(jq -r '.git.email // ""' "$SECRETS_FILE" 2>/dev/null || echo "")
    if [ -n "$GIT_NAME" ] && [ -n "$GIT_EMAIL" ]; then
        git config --global user.name "$GIT_NAME"
        git config --global user.email "$GIT_EMAIL"
        GIT_IDENTITY_STATUS="$GIT_NAME <$GIT_EMAIL>"
        echo "[install] Git identity restored: $GIT_NAME <$GIT_EMAIL>"
    else
        echo "[install] Git identity not found in secrets.json — set manually or run save-secrets"
    fi
fi

# Hydrate {{TOKEN}} placeholders in plugin MCP configs from secrets.json
hydrate_plugin_mcp() {
    local plugin_mcp="$1"
    local secrets_file="$2"
    local hydrated="$plugin_mcp"

    # Iterate over each server to hydrate per-plugin secrets
    local servers
    servers=$(echo "$plugin_mcp" | jq -r 'keys[]' 2>/dev/null || true)

    for server in $servers; do
        # Get plugin name from _source tag
        local p_name
        p_name=$(echo "$plugin_mcp" | jq -r --arg s "$server" '.[$s]._source // "" | sub("^plugin:"; "")' 2>/dev/null || echo "")
        [ -z "$p_name" ] && continue

        # Extract {{TOKEN}} patterns from this server's config
        local server_json
        server_json=$(echo "$plugin_mcp" | jq --arg s "$server" '.[$s]' 2>/dev/null || echo "{}")
        local server_tokens
        server_tokens=$(echo "$server_json" | grep -oP '\{\{[A-Z_]+\}\}' | sort -u || true)

        for token_pattern in $server_tokens; do
            local token_name
            token_name=$(echo "$token_pattern" | sed 's/{{//;s/}}//')

            # Namespaced lookup: secrets.json["plugin-name"]["TOKEN_NAME"]
            local secret_value=""
            if [ -f "$secrets_file" ]; then
                secret_value=$(jq -r --arg p "$p_name" --arg k "$token_name" \
                    '.[$p][$k] // ""' "$secrets_file" 2>/dev/null || echo "")
            fi

            # Warn if missing (per user decision: inline warning, no crash)
            if [ -z "$secret_value" ]; then
                echo "⚠ $p_name: missing $token_name"
            fi

            # Hydrate using jq walk+gsub (safe for special characters in secrets)
            hydrated=$(echo "$hydrated" | jq \
                --arg token "$token_pattern" \
                --arg value "$secret_value" \
                'walk(if type == "string" then gsub($token; $value) else . end)' 2>/dev/null || echo "$hydrated")
        done
    done

    echo "$hydrated"
}

# Generate .mcp.json — unified: plugin servers (hydrated) + base template servers
MCP_JSON='{"mcpServers":{}}'

# Step 1: Add hydrated plugin MCP servers
if [ "$PLUGIN_MCP" != "{}" ]; then
    HYDRATED_PLUGIN_MCP=$(hydrate_plugin_mcp "$PLUGIN_MCP" "$SECRETS_FILE")
    MCP_JSON=$(echo "$MCP_JSON" | jq --argjson plugin "$HYDRATED_PLUGIN_MCP" \
        '.mcpServers = $plugin')
    PLUGIN_MCP_COUNT=$(echo "$HYDRATED_PLUGIN_MCP" | jq 'length' 2>/dev/null || echo "0")
    MCP_COUNT=$((MCP_COUNT + PLUGIN_MCP_COUNT))
fi

# Step 2: Add base template servers from config.json
if [ -f "$CONFIG_FILE" ]; then
    ENABLED_SERVERS=$(jq -r '.mcp_servers | to_entries[] | select(.value.enabled == true) | .key' "$CONFIG_FILE" 2>/dev/null || echo "")

    if [ -n "$ENABLED_SERVERS" ]; then
        for SERVER in $ENABLED_SERVERS; do
            TEMPLATE_FILE="$MCP_TEMPLATES_DIR/${SERVER}.json"
            if [ -f "$TEMPLATE_FILE" ]; then
                HYDRATED=$(sed "s|{{MCP_GATEWAY_URL}}|$MCP_GATEWAY_URL|g" "$TEMPLATE_FILE")
                MCP_JSON=$(echo "$MCP_JSON" | jq --argjson server "{\"$SERVER\": $HYDRATED}" '.mcpServers += $server')
                MCP_COUNT=$((MCP_COUNT + 1))
            else
                echo "[install] WARNING: Template $TEMPLATE_FILE not found for enabled server $SERVER"
            fi
        done
    fi
fi

# Fallback: if no servers at all, add default mcp-gateway
SERVER_COUNT=$(echo "$MCP_JSON" | jq '.mcpServers | length')
if [ "$SERVER_COUNT" -eq 0 ]; then
    MCP_JSON='{"mcpServers":{"mcp-gateway":{"type":"sse","url":"'"$MCP_GATEWAY_URL"'/sse"}}}'
    MCP_COUNT=1
fi

echo "$MCP_JSON" > "$CLAUDE_DIR/.mcp.json"
echo "[install] Generated .mcp.json with $MCP_COUNT server(s)"

# Generate infra/.env from secrets.json if infra section exists
INFRA_ENV_STATUS="skipped — no infra secrets"
if [ -f "$SECRETS_FILE" ]; then
    HAS_INFRA=$(jq -e '.infra.postgres_password // empty' "$SECRETS_FILE" 2>/dev/null && echo "yes" || echo "")
    if [ -n "$HAS_INFRA" ]; then
        if command -v langfuse-setup &>/dev/null; then
            langfuse-setup --generate-env 2>/dev/null && INFRA_ENV_STATUS="generated" || INFRA_ENV_STATUS="failed"
            echo "[install] infra/.env: $INFRA_ENV_STATUS"
        else
            echo "[install] WARNING: langfuse-setup not on PATH — skipping .env generation"
        fi
    fi
fi

# Detect unresolved {{PLACEHOLDER}} tokens in generated files (GEN-06)
UNRESOLVED=""
for generated_file in "$CLAUDE_DIR/settings.json" "$CLAUDE_DIR/.mcp.json"; do
    if [ -f "$generated_file" ]; then
        tokens=$(grep -oP '\{\{[A-Z_]+\}\}' "$generated_file" 2>/dev/null || true)
        if [ -n "$tokens" ]; then
            UNRESOLVED="$UNRESOLVED $tokens"
            # Replace unresolved tokens with empty strings
            sed -i 's/{{[A-Z_]*}}//g' "$generated_file"
        fi
    fi
done
if [ -n "$UNRESOLVED" ]; then
    echo "[install] WARNING: Unresolved placeholders replaced with empty strings:$UNRESOLVED"
fi

# Install GSD framework
if [ -d "$CLAUDE_DIR/commands/gsd" ] && [ "$(ls -A "$CLAUDE_DIR/commands/gsd" 2>/dev/null)" ]; then
    echo "[install] GSD: already installed, skipping"
    # Count existing installation
    GSD_COMMANDS=$(find "$CLAUDE_DIR/commands/gsd" -name "*.md" 2>/dev/null | wc -l || echo 0)
    GSD_AGENTS=$(find "$CLAUDE_DIR/agents" -name "*.md" 2>/dev/null | wc -l || echo 0)
else
    echo "[install] Installing GSD framework..."
    if npx get-shit-done-cc --claude --global > /dev/null 2>&1; then
        echo "[install] GSD framework installed"
        # Count after installation
        GSD_COMMANDS=$(find "$CLAUDE_DIR/commands/gsd" -name "*.md" 2>/dev/null | wc -l || echo 0)
        GSD_AGENTS=$(find "$CLAUDE_DIR/agents" -name "*.md" 2>/dev/null | wc -l || echo 0)
    else
        echo "[install] WARNING: GSD installation failed"
        GSD_COMMANDS=0
        GSD_AGENTS=0
    fi
fi

# Enforce required settings.json values AFTER GSD (which modifies the file).
jq '.permissions.defaultMode = "bypassPermissions" | .effortLevel = "high" | .model = "opus" | .skipDangerousModePermissionPrompt = true' \
    "$CLAUDE_DIR/settings.json" > "$CLAUDE_DIR/settings.json.tmp" \
    && mv "$CLAUDE_DIR/settings.json.tmp" "$CLAUDE_DIR/settings.json"
echo "[install] Enforced settings.json (bypassPermissions, opus, effortLevel: high)"

# --- Merge template + plugin hooks/env into settings.json ---
# Done AFTER GSD install + enforcement so nothing overwrites these values.
# Claude Code only reads hooks and env from settings.json (not settings.local.json).

# Merge hydrated template (hooks, env, additionalDirectories) into settings.json
if [ "$HYDRATED_SETTINGS" != "{}" ]; then
    jq --argjson tmpl "$HYDRATED_SETTINGS" '
        # Merge hooks: append template hook arrays to existing arrays per event
        .hooks = ((.hooks // {}) as $existing |
            ($tmpl.hooks // {}) | to_entries | reduce .[] as $entry ($existing;
                .[$entry.key] = ((.[$entry.key] // []) + $entry.value)
            )
        ) |
        # Merge env vars (template values, may be overridden by plugins below)
        .env = ((.env // {}) + ($tmpl.env // {})) |
        # Merge additionalDirectories
        .permissions.additionalDirectories = (
            ((.permissions.additionalDirectories // []) + ($tmpl.permissions.additionalDirectories // [])) | unique
        )
    ' "$CLAUDE_DIR/settings.json" > "$CLAUDE_DIR/settings.json.tmp" \
        && mv "$CLAUDE_DIR/settings.json.tmp" "$CLAUDE_DIR/settings.json"
    echo "[install] Merged template hooks + env into settings.json"
fi

# Merge plugin hooks into settings.json
if [ "$PLUGIN_HOOKS" != "{}" ]; then
    jq --argjson plugin_hooks "$PLUGIN_HOOKS" '
        reduce ($plugin_hooks | to_entries[]) as $entry (.;
            .hooks[$entry.key] = ((.hooks[$entry.key] // []) + [{"hooks": $entry.value}])
        )
    ' "$CLAUDE_DIR/settings.json" > "$CLAUDE_DIR/settings.json.tmp" \
        && mv "$CLAUDE_DIR/settings.json.tmp" "$CLAUDE_DIR/settings.json"
    echo "[install] Merged plugin hooks into settings.json"
fi

# Merge plugin env vars into settings.json
if [ "$PLUGIN_ENV" != "{}" ]; then
    jq --argjson plugin_env "$PLUGIN_ENV" '.env = ((.env // {}) + $plugin_env)' \
        "$CLAUDE_DIR/settings.json" > "$CLAUDE_DIR/settings.json.tmp" \
        && mv "$CLAUDE_DIR/settings.json.tmp" "$CLAUDE_DIR/settings.json"
    echo "[install] Merged plugin env vars into settings.json"
fi

# Print summary
echo "[install] --- Summary ---"
echo "[install] Config: $CONFIG_STATUS"
echo "[install] Secrets: $SECRETS_STATUS"
echo "[install] Settings: generated"
echo "[install] Credentials (Claude): $CREDS_STATUS"
echo "[install] Credentials (Codex): $CODEX_CREDS_STATUS"
echo "[install] Git identity: $GIT_IDENTITY_STATUS"
echo "[install] Skills: $SKILLS_COUNT skill(s) -> Claude + Codex"
echo "[install] Hooks: $HOOKS_COUNT hook(s)"
echo "[install] Commands: $COMMANDS_COUNT standalone command(s)"
echo "[install] Plugins: $PLUGIN_INSTALLED installed, $PLUGIN_SKIPPED skipped"
echo "[install] MCP: $MCP_COUNT server(s)"
echo "[install] Infra .env: $INFRA_ENV_STATUS"
echo "[install] GSD: $GSD_COMMANDS commands + $GSD_AGENTS agents"
echo "[install] Done."
