---
phase: 03-claude-code-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .devcontainer/devcontainer.json
  - .devcontainer/Dockerfile
  - langfuse-local/mcp/mcp.json
  - langfuse-local/mcp/SERVERS.md
autonomous: true

must_haves:
  truths:
    - "Running the mcp-setup shell function generates .mcp.json at the workspace root"
    - "Shell function polls gateway health endpoint and waits up to 30 seconds"
    - "If gateway is not healthy within 30s, function warns and continues (non-blocking)"
    - "Generated .mcp.json contains single SSE gateway endpoint using MCP_GATEWAY_URL"
    - "MCP_GATEWAY_URL environment variable is set in devcontainer containerEnv"
    - "Example MCP server configurations exist as reference for adding new servers"
  artifacts:
    - path: ".devcontainer/devcontainer.json"
      provides: "MCP_GATEWAY_URL environment variable"
      contains: "MCP_GATEWAY_URL"
    - path: ".devcontainer/Dockerfile"
      provides: "Shell function for .mcp.json generation and health polling"
      contains: "mcp-setup"
    - path: "langfuse-local/mcp/SERVERS.md"
      provides: "Example MCP server configurations for user reference"
      contains: "mcpServers"
    - path: "langfuse-local/mcp/mcp.json"
      provides: "Active MCP server configuration (filesystem server)"
  key_links:
    - from: ".devcontainer/Dockerfile"
      to: ".devcontainer/devcontainer.json"
      via: "MCP_GATEWAY_URL env var referenced in shell function"
      pattern: "MCP_GATEWAY_URL"
    - from: "shell function (mcp-setup)"
      to: "/workspace/.mcp.json"
      via: "generates .mcp.json with gateway SSE endpoint"
      pattern: "mcp-setup"
    - from: "/workspace/.mcp.json"
      to: "http://host.docker.internal:8811"
      via: "SSE transport URL in mcpServers config"
      pattern: "host.docker.internal:8811"
---

<objective>
Wire Claude Code to auto-connect to the MCP gateway by creating a shell function that generates `.mcp.json` at the workspace root, polls the gateway health endpoint, and provides example server configurations for adding new MCP servers.

Purpose: This is the final phase — making MCP tools available to Claude Code sessions without manual configuration. After this, any Claude Code session started in the devcontainer will have MCP tools available immediately.

Output: Modified Dockerfile with shell function, updated devcontainer.json with MCP_GATEWAY_URL env var, example server documentation alongside gateway config.
</objective>

<execution_context>
@/home/node/.claude/get-shit-done/workflows/execute-plan.md
@/home/node/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-gateway-infrastructure/01-01-SUMMARY.md
@.planning/phases/02-connectivity-health-validation/02-01-SUMMARY.md
@.devcontainer/devcontainer.json
@.devcontainer/Dockerfile
@langfuse-local/mcp/mcp.json
@langfuse-local/docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MCP_GATEWAY_URL env var and mcp-setup shell function</name>
  <files>.devcontainer/devcontainer.json, .devcontainer/Dockerfile</files>
  <action>
**devcontainer.json changes:**

Add `MCP_GATEWAY_URL` to the existing `containerEnv` section:
```json
"MCP_GATEWAY_URL": "http://host.docker.internal:8811"
```

This goes alongside the existing env vars (NODE_OPTIONS, CLAUDE_CONFIG_DIR, etc.).

**Dockerfile changes:**

Add a shell function (not alias — per research, functions handle multi-line logic better) to BOTH .bashrc and .zshrc. Place it in the same RUN block that already adds the `claudey`/`claudeyr` aliases (lines 130-133), extending that block.

The function should be named `mcp-setup` and do the following:

1. **Generate `.mcp.json`** at `/workspace/.mcp.json` containing a single gateway SSE endpoint:
   ```json
   {
     "mcpServers": {
       "mcp-gateway": {
         "type": "sse",
         "url": "${MCP_GATEWAY_URL}/sse"
       }
     }
   }
   ```
   Use the `MCP_GATEWAY_URL` environment variable (set via devcontainer.json containerEnv). If MCP_GATEWAY_URL is not set, default to `http://host.docker.internal:8811`.

2. **Poll gateway health endpoint** at `${MCP_GATEWAY_URL}/health` (or the default URL + /health):
   - Use curl with `--retry 15 --retry-delay 2 --retry-max-time 30 --retry-connrefused` for retry logic
   - Silent mode (`-s -o /dev/null -w "%{http_code}"`)
   - If health check returns 200: print success message with green checkmark
   - If health check fails after 30s: print warning (yellow) that gateway is not ready, but DO NOT exit with error — continue gracefully. Print suggestion: "Start the gateway: cd /workspace/claudehome/langfuse-local && docker compose up -d docker-mcp-gateway"

3. **Print summary** after completion:
   - Config file path: `/workspace/.mcp.json`
   - Gateway URL used
   - Reminder: "Restart Claude Code session to pick up MCP tools" (since Claude Code doesn't hot-reload .mcp.json)
   - For adding servers: "Edit langfuse-local/mcp/mcp.json, restart gateway, then re-run mcp-setup"

Implementation notes:
- Use a heredoc for the JSON generation (via `cat <<EOF > /workspace/.mcp.json`) — do NOT use jq since the output is static/simple
- The function goes in both .bashrc AND .zshrc (matching the pattern used for claudey/claudeyr aliases)
- Keep the function compact — under 30 lines
- Do NOT add the function call to postStartCommand or postCreateCommand (user wants manual alias invocation per CONTEXT.md decision: "Triggered via shell alias defined in shell profile")
- The MCP_GATEWAY_URL variable is read at function runtime (not at build time), so the heredoc must use the variable, not a hardcoded value

IMPORTANT: The `.mcp.json` uses SSE transport type. The research notes HTTP transport is now preferred, but the gateway is configured with `--transport sse` (from Phase 2 docker-compose.yml). Use SSE to match the actual gateway configuration. The URL path is `/sse` appended to the gateway base URL.
  </action>
  <verify>
1. Read the modified Dockerfile and verify the function is defined in both .bashrc and .zshrc RUN blocks
2. Read devcontainer.json and verify MCP_GATEWAY_URL is in containerEnv
3. Verify the function generates valid JSON by inspecting the heredoc content
4. Verify the curl retry logic uses --retry-max-time 30 (matching the 30s timeout decision)
5. Verify no postStartCommand or postCreateCommand changes were made
  </verify>
  <done>
- MCP_GATEWAY_URL is set in devcontainer.json containerEnv as "http://host.docker.internal:8811"
- Shell function `mcp-setup` is defined in both .bashrc and .zshrc via the Dockerfile
- Function generates .mcp.json with SSE transport pointing to gateway
- Function polls health endpoint with 30s max timeout using curl retry
- Function warns but does not fail if gateway is unreachable
- Function prints actionable summary including restart reminder
  </done>
</task>

<task type="auto">
  <name>Task 2: Add example MCP server documentation and update gateway config</name>
  <files>langfuse-local/mcp/SERVERS.md, langfuse-local/mcp/mcp.json</files>
  <action>
**JSON comment limitation:** The user requested "inline in mcp.json as commented-out examples." JSON does not support comments (flagged in research as pitfall #1). Adding example entries directly to mcp.json would cause the gateway to try starting non-existent servers and fail. Instead, create a companion documentation file `langfuse-local/mcp/SERVERS.md` right next to mcp.json — this is "inline" in the sense of being co-located where the user edits.

**langfuse-local/mcp/SERVERS.md:**

Create a lean reference file (per user decision: "No troubleshooting section — keep it lean, happy path only"). Structure:

```markdown
# MCP Servers

Add servers to `mcp.json`, restart the gateway, then run `mcp-setup` in the devcontainer.

## Active Servers

- **filesystem** — File operations in /workspace (pre-configured)

## Example Servers

Copy any entry below into the `mcpServers` object in `mcp.json`.

### GitHub (via official MCP server)

\```json
"github": {
  "command": "npx",
  "args": ["-y", "@modelcontextprotocol/server-github"],
  "env": {
    "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_TOKEN}"
  }
}
\```

Requires: Set GITHUB_TOKEN in `langfuse-local/.env`

### PostgreSQL (query Langfuse database)

\```json
"postgres": {
  "command": "npx",
  "args": ["-y", "@modelcontextprotocol/server-postgres", "postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/postgres"],
  "env": {}
}
\```

Uses the existing Langfuse PostgreSQL instance.

### Brave Search (web search from Claude Code)

\```json
"brave-search": {
  "command": "npx",
  "args": ["-y", "@modelcontextprotocol/server-brave-search"],
  "env": {
    "BRAVE_API_KEY": "${BRAVE_API_KEY}"
  }
}
\```

Requires: Set BRAVE_API_KEY in `langfuse-local/.env` (get from https://brave.com/search/api/)

## Workflow

1. Copy a server entry into `mcp.json` under `mcpServers`
2. Add any required env vars to `langfuse-local/.env`
3. Restart: `cd /workspace/claudehome/langfuse-local && docker compose restart docker-mcp-gateway`
4. Re-run: `mcp-setup`
5. Restart Claude Code session
```

**Choosing example servers (Claude's discretion):** GitHub, PostgreSQL, and Brave Search were selected because:
- GitHub: Most relevant for a dev environment — code context
- PostgreSQL: Already running in this stack (Langfuse uses it) — zero additional infrastructure
- Brave Search: Web search capability is highly useful for Claude Code sessions

**langfuse-local/mcp/mcp.json:**

Leave the existing mcp.json unchanged. It already has the filesystem server correctly configured. The examples go in SERVERS.md, not in mcp.json (to avoid gateway startup failures from non-existent servers).
  </action>
  <verify>
1. Verify langfuse-local/mcp/SERVERS.md exists and contains 3 example server entries
2. Verify each example has valid JSON syntax in code blocks
3. Verify langfuse-local/mcp/mcp.json is unchanged (still only has filesystem server)
4. Verify SERVERS.md references the correct workflow: edit mcp.json -> restart gateway -> run mcp-setup -> restart Claude Code
5. Verify no troubleshooting section exists (per user decision)
  </verify>
  <done>
- SERVERS.md exists at langfuse-local/mcp/SERVERS.md with 3 example server configurations
- Examples are GitHub, PostgreSQL, and Brave Search (relevant to this devcontainer ecosystem)
- Each example includes the JSON entry to copy and any required env vars
- Workflow section documents: edit -> restart -> mcp-setup -> restart Claude Code
- mcp.json is unchanged (no risk of gateway startup failures from example entries)
- Documentation is lean: happy path only, no troubleshooting
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full integration:

1. **Config generation:** The shell function (if manually invoked in current container) should generate a valid `.mcp.json` at `/workspace/.mcp.json`. Test by sourcing the function and running it:
   ```bash
   # Source the function definition and test it
   source <(grep -A 30 'mcp-setup' /home/node/.zshrc) 2>/dev/null
   mcp-setup
   cat /workspace/.mcp.json | jq .
   ```

2. **JSON validity:** The generated `.mcp.json` must be valid JSON with `mcpServers.mcp-gateway` containing `type: "sse"` and `url` ending in `/sse`.

3. **Health check behavior:** If gateway is running, function should succeed quickly. If not running, function should warn after ~30s but not exit with error.

4. **File inventory:**
   - `.devcontainer/devcontainer.json` has `MCP_GATEWAY_URL` in containerEnv
   - `.devcontainer/Dockerfile` has mcp-setup function in both shell configs
   - `langfuse-local/mcp/SERVERS.md` has 3 example servers
   - `langfuse-local/mcp/mcp.json` is unchanged
</verification>

<success_criteria>
- Shell function `mcp-setup` is available in devcontainer terminals (zsh and bash)
- Running `mcp-setup` generates valid `/workspace/.mcp.json` with SSE gateway endpoint
- Health polling respects 30s timeout with graceful degradation
- MCP_GATEWAY_URL environment variable drives the gateway URL (not hardcoded in function)
- Example server documentation exists co-located with mcp.json
- All 3 Phase 3 requirements addressed: CONN-02 (auto-connect config), VERIF-01 (e2e capability), VERIF-03 (multi-server workflow)
</success_criteria>

<output>
After completion, create `.planning/phases/03-claude-code-integration/03-01-SUMMARY.md`
</output>
